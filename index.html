<!DOCTYPE html>

</html>

<head>
  <title>svift_v1</title>
  <meta charset="utf-8">
  <link rel="stylesheet" href="styles/app/normalize.css">
  <link rel="stylesheet" href="styles/app/app.css">
  <link rel="stylesheet" href="styles/bot/bot.css">
  <link href="https://fonts.googleapis.com/css?family=Noto+Serif|Open+Sans|Roboto+Mono" rel="stylesheet">

  <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
  <link rel="manifest" href="favicon/manifest.json">
  <link rel="mask-icon" href="favicon/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="shortcut icon" href="favicon/favicon.ico">
  <meta name="msapplication-config" content="favicon/browserconfig.xml">
  <meta name="theme-color" content="#ffffff">
</head>

<body>

  <div class="app">
    <div id="gui-1" class="gui">
      <header>

        <div class='svift-logo'>
          <!-- <img src="assets/img/wordmark-white.png" alt="Svift Logo"> -->
        </div>
        <div class='burger'>
          <div class="bar1"></div>
          <div class="bar2"></div>
          <div class="bar3"></div>
        </div>
      </header>
      <main>
        <h1>Your social chart tool</h1>
        <div class="claim">
          <em>svift</em> is an open source tool to turn numbers into charts for social media.
          <br> It is easy, super fast and fun. Try our prototype now and let us know what you think.
        </div>
      </main>
      <nav>
        <div class='close'></div>
        <ul>
          <li>
            <a href="pages.html#about">About</a>
          </li>
          <li>
            <a href="pages.html#docs">Docs</a>
          </li>
          <li>
            <a href="pages.html#contact">Contact</a>
          </li>
          <li>
            <a href="pages.html#pro">Pro*</a>
          </li>
        </ul>
      </nav>

      <div class="hero"></div>
      <div id="gui-1-overlay"></div>
    </div>
    <div id="gui-2" class="gui">
    </div>
  </div>

  <script src="build/d3.v4.min.js"></script>
  <script src="build/svift.min.js"></script>
  <script src="chatbot.js"></script>
  <script type="text/javascript">

    // Show / hide Nav (needs to be cleaned up here..)
    // var nav = d3.select('nav');
    // var heightNav = nav.node().getBoundingClientRect().height;
    // console.log(-heightNav);

    d3.select('.burger')
      .on('click', function () {
        d3.select('nav').style('top', 0);
      });

    d3.select('.close')
      .on('click', function () {
        d3.select('nav').style('top', '-400px');
      });


    var heroku = 'https://svift-backend.herokuapp.com';

    d3.request(heroku + '/hello').get(function () { console.log('server is awake'); });


    SVIFT.vis.config = {
      "params": {
        "dev": true
      },
      "vis": {
        "type": "",
        "title": ""
      },
      "length": 3000,
      "style": {
        "font": "Open Sans",
        "fontLables": "InterfaceRegular",
        "color": {
          "main": "#71609B",
          "second": "#D8D8D8",
          "background": "#fff",
          "dataColors": ["#434343", "#FF5858", "#99C3F3", "#FFF680", "#EF96FF", "#B9FF6C"]
        }
      },
      "data": {
        "columns": ["Wert"],
        "types": ["int"],
        // "format": "",
        "data": {"set1":[["A", 25], ["B", 20]],"set2":[["d", 25], ["e", 20]]},
        "title": "Your title",
        "subTitle": "Your subtitle",
        "attribution": "made with svift.xyz",
        "source": "Source: Your source"
      }
    }


    SVIFT.vis.init = function (vistype) {

      //load data for specific vis type
      d3.json('./build/data/' + vistype + '.json', function (err, visData) {
        if (err) { console.log(err); }
        console.log(visData.data.format)

        SVIFT.vis.config.vis.type = vistype;
        SVIFT.vis.config.data.format = visData.data.format;
        // SVIFT.vis.config.data.data = visData.data.data;

        // "multi-set"
        // if (vistype == "columns") {
        //   SVIFT.vis.config.data.format = "single-set"; //
        //   SVIFT.vis.config.data.data = {"set1":[["A", 25], ["B", 20]],"set2":[["d", 25], ["e", 20]]}
        // }


        // {"set1":[["A", 25], ["B", 20]],"set2":[["d", 25], ["e", 20]]}

        var overlay = d3.select('#gui-1-overlay').html('');

        var vizContainer = overlay.append('div')
          .attr('class', 'viz-container')
          .style('opacity', 0)
          .style('height', (d3.select("#gui-1-overlay").node().getBoundingClientRect().width * .7) + "px")
          .transition()
          .style('opacity', 1)

        d3.select('.viz-container').append('div').attr('class', 'viz-eyebrow').text('Selected chart type: ' + SVIFT.vis.config.vis.type);

        var vis = SVIFT.vis[SVIFT.vis.config.vis.type](SVIFT.vis.config, d3.select('.viz-container'));
        vis.init();
        vis.start();

      })

    }



    SVIFT.vis.redraw = function () {

      var type = SVIFT.vis.config.vis.type;
      var data = SVIFT.vis.config;

      d3.select('.viz-container svg').remove();
      var vis = SVIFT.vis[SVIFT.vis.config.vis.type](data, d3.select('.viz-container'));
      vis.init();
      vis.start();

    }



    SVIFT.vis.resize = function (format) {

      var containerWidth = d3.select(".viz-container").node().getBoundingClientRect().width;
      d3.select(".viz-container")
        .style("height", (containerWidth / format[0]) * format[1] + "px");

    }



    SVIFT.vis.render = function () {

      
      d3.request(heroku + '/render')
        .header("Content-Type", "application/json")
        .mimeType("application/json")
        .post(
        JSON.stringify(SVIFT.vis.config),
        function (err, rawData) {

          inter = setInterval(function () {
            d3.request(heroku + '/status/' + rawData.response).get(function (err, data) {

              var jResponse = JSON.parse(data.response);
              var statusCounter = 0;
              SVIFT.vis.render.token = rawData.response;
              console.log(jResponse)

              for (var type in jResponse.full) {

                if(jResponse.full[type]==1){

                  statusCounter++;
                  SVIFT.vis.render.status.rendered[type] = true;

                }

              }

              //All things have been rendered stop request
              if (statusCounter==5){clearInterval(inter);}

              SVIFT.vis.render.status.show()

            });
          }, 1000);
        }
        );
    }

    SVIFT.vis.render.token = "";
    SVIFT.vis.render.status = {};
    SVIFT.vis.render.status.visible = false;

    SVIFT.vis.render.status.rendered = {
      "gif": false,
      "html": false,
      "png": false,
      "social": false,
      "svg": false
    }


    SVIFT.vis.render.status.show = function(){

      if(SVIFT.vis.render.status.visible){

        var status = SVIFT.vis.render.status.rendered;
        var counter = 0;

        for (var type in status) {

          if(status[type]){

            counter++;

            if(type == 'social'){
              SVIFT.status.rows.rowOne.selectAll('span')
                .transition()
                .delay(function (d, i) { return i * 400 })
                .attr('class', 'complete');
                
            }else{
              d3.select('#status-' + type).attr('class', 'complete')
            }

          }

        }  

        if(counter==5){

          setTimeout(function () {

            doneRendering();

          },1500)

        }

      }    

    }


    //Data input table
    SVIFT.table = {};
    SVIFT.table.maxRows = 15;
    SVIFT.table.minRows = 2;

    SVIFT.table.column = {};

    SVIFT.table.column.add = function () {

      if (SVIFT.vis.config.data.data['set1'].length >= SVIFT.table.minRows) {
        d3.select(".column-editor-btn.btn-remove").classed('disabled-btn', false);
      }

      if (SVIFT.vis.config.data.data['set1'].length === SVIFT.table.maxRows) {
        return
      }


      var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

      var lastEntry = SVIFT.vis.config.data.data['set1'][SVIFT.vis.config.data.data['set1'].length - 1];
      SVIFT.vis.config.data.data['set1'].push([alphabet[SVIFT.vis.config.data.data['set1'].length], lastEntry[1]])

      SVIFT.table.column.title.selectAll('td')
        .data(SVIFT.vis.config.data.data['set1']).enter().append('td')
        .append('input')
        .attr('placeholder', function (d, i) { return alphabet[i] })
        .attr("data-index", function (d, i) { return i })
        .on('input', SVIFT.helper.debouncer(function () {
          SVIFT.table.lables.update(this);
          SVIFT.vis.redraw()
        }, 500));

      SVIFT.table.column.number.selectAll('td')
        .data(SVIFT.vis.config.data.data['set1']).enter()
        .append('td').append('input')
        .attr('placeholder', function (d) { return d[1] })
        .attr("data-index", function (d, i) { return i })
        .on('input', SVIFT.helper.debouncer(function () {
          SVIFT.table.values.update(this);
          SVIFT.vis.redraw()
        }, 500))

      SVIFT.vis.redraw();

      if (SVIFT.vis.config.data.data['set1'].length === SVIFT.table.maxRows) {
        d3.select(".column-editor-btn.btn-add").classed('disabled-btn', true);
      }

    }

    SVIFT.table.column.remove = function () {

      var amountButtons = SVIFT.vis.config.data.data['set1'].length;
      if (amountButtons === SVIFT.table.minRows) {
        return
      }
      if (amountButtons === 3) {
        d3.select(".column-editor-btn.btn-remove").classed('disabled-btn', true)
      }
      if (amountButtons <= SVIFT.table.maxRows) {
        d3.select(".column-editor-btn.btn-add").classed('disabled-btn', false)
      }

      SVIFT.vis.config.data.data['set1'].pop();

      SVIFT.table.column.title.selectAll('td')
        .data(SVIFT.vis.config.data.data['set1']).exit().remove();

      SVIFT.table.column.number.selectAll('td')
        .data(SVIFT.vis.config.data.data['set1']).exit().remove();

      SVIFT.vis.redraw();

    };

    SVIFT.table.data = {};

    SVIFT.table.data.validate = function (d) {

      var inputValue = d.replace(",", ".");
      if (isNaN(inputValue)) {
        inputValue = null;
        return null
      } else {
        inputValue = Number(inputValue);
        return inputValue;
      }

    };

    SVIFT.table.values = {};
    SVIFT.table.values.update = function (obj) {

      d3.select(obj).attr('placeholder', null);

      var dataPosition = d3.select(obj).attr("data-index");
      var inputValue = d3.select(obj).node().value;
      var newData = SVIFT.table.data.validate(inputValue);

      if (newData > 100 && SVIFT.vis.config.vis.type == "mosaic") {
        newData = Number(newData.toString().slice(0, 2));
        d3.select("#number").property("value", newData);
      }

      if (newData == null) {
        d3.select(obj).classed('bad-input-data', true)
      } else {
        d3.select(obj).classed('bad-input-data', false)
      }

      SVIFT.vis.config.data.data['set1'][dataPosition][1] = newData;

      SVIFT.vis.redraw();

    }

    SVIFT.table.lables = {};

    SVIFT.table.lables.update = function (obj) {

      d3.select(obj).attr('placeholder', '');

      var dataPosition = d3.select(obj).attr("data-index");
      var inputValue = d3.select(obj).node().value;
      SVIFT.vis.config.data.data['set1'][dataPosition][0] = inputValue || '';

      SVIFT.vis.redraw();

    }

    SVIFT.table.text = {};

    SVIFT.table.text.update = function (selectorViz, selectorInput, selectorData, altText) {

      var inputText = d3.select(selectorInput).node().value;
      SVIFT.vis.config.data[selectorData] = inputText || altText;
      if (selectorData == "source" && inputText) { SVIFT.vis.config.data[selectorData] = "Source: " + inputText };
      d3.select(selectorViz).text(SVIFT.vis.config.data[selectorData]);

    }

    SVIFT.table.text.toogle = function (obj, selectorViz, selectorInput, selectorData, altText) {

      var hidden = d3.select(obj.parentNode).classed("hidden");

      if (!hidden) {
        d3.select(obj.parentNode).classed("hidden", true);

        var inputText = "";
        SVIFT.vis.config.data[selectorData] = inputText;
        if (selectorData == "source" && inputText) { SVIFT.vis.config.data[selectorData] = "Source: " + inputText };
        d3.select(selectorViz).text(SVIFT.vis.config.data[selectorData]);

      }
      else {
        d3.select(obj.parentNode).classed("hidden", false);

        var inputText = d3.select(selectorInput).node().value;
        SVIFT.vis.config.data[selectorData] = inputText || altText;
        if (selectorData == "source" && inputText) { SVIFT.vis.config.data[selectorData] = "Source: " + inputText };
        d3.select(selectorViz).text(SVIFT.vis.config.data[selectorData]);
      }

    }








    var cb;

    d3.json('./build/config.json', function (err, data) {
      if (err) { console.log(err); }

      /*
    
        //data contains an array of available visualisation types:
    
        //the thumbnails are available under:
        for(var key in data){
          var src = './build/thumbs/'+key+'_thumb.png';
          var src2 = './build/thumbs/'+key+'_thumb@2x.png';
        }

    
        //in order to load more config info on the selected vis load:
    
        d3.json('./build/'+key+'.json', function(err, data){
          //This json contains title and input method, in the future we can pack more meta data into this json, which will help us automatically generate the chatbot steps, right now only the data.input is relevant (we should come up with a set of rules)
        });
    
        //as we are using svift.min.js, which contains all available visualisations, we don't need to load individual vis types
        //in order to initiate one visualisation:
        for(var key in data){
          var vis = SVIFT.vis[(key.split('-'))[2]](DATA_FOR_VIS, d3.select('#VIS_CONTAINER'));
            vis.init();
            vis.start(); 
        }
    
        //After all elements are being entered, the resulting vis can be send to the backend via
        //The structure of output is collected from the vis modules
    
        var output = {
          "params":{
            "dev":true
          },
          "vis":{
            "type":"barchart",
            "title":"Barchart"
          },
          "data":{
            "columns":["Jahr","Wert"],
            "types":["date","int"],
            "data":[
              [2017,3.9],
              [2016,4.1],
              [2015,4.6],
              [2014,5.0],
              [2013,5.2],
              [2012,5.5],
              [2011,5.9],
              [2010,7.1],
              [2009,7.8]
            ]
          }
        };
    
        //The request will return an ID
    
        d3.xhr(URL OF SERVER)
          .header("Content-Type", "application/json")
          .post(
              JSON.stringify(output),
              function(err, rawData){
                  var data = JSON.parse(rawData);
                  console.log("got response", data);
              }
          );
    
        //This ID can then be used to poll the backend every 200 - milliseconds, in order to get the status of the rendering (right now this only returns an output when everything is done, this will be my (SEB) TODO for the weekend to send detailed progress information, but it will be something like this:
    
        //for each type the result is 0-1 (1 = done)
    
        var feedback = {
          svg:0.5,
          png:1,
          html:1,
          ...
        };
    
        //The ID is also equivalent to the permanent (7 day) url: svift.xyz/?/ID/ (index.html) > the index.html is actually not yet there, but i (SEB) will also take care of this...
      */




      //Make thumbs
      // createThumbs();

      function createThumbs() {

        d3.select('#gui-1-overlay').style('left', '0');

        var overlay = d3.select('#gui-1-overlay')
          .style('background-color', '#75FABF')
          .append('div')
          .attr('class', 'thumb-wrapper');

        var thumb = overlay.selectAll('.thumb')
          .data(d3.keys(data)).enter().append('div')
          .attr('class', 'thumb')
          .attr('id', function (d) { return 'thumb-' + d });

        thumb
          .append('img')
          .attr('src', function (d) {
            var mediaQuery = "(-webkit-min-device-pixel-ratio: 1.5),\
                    (min--moz-device-pixel-ratio: 1.5),\
                    (-o-min-device-pixel-ratio: 3/2),\
                    (min-resolution: 1.5dppx)";
            if (window.devicePixelRatio > 1 && window.matchMedia && window.matchMedia(mediaQuery).matches) {
              return './build/thumbs/' + d + '_thumb@2x.png'
            } else {
              return './build/thumbs/' + d + '_thumb.png'
            }
          })
          .on('click', selectViz)
          .style('opacity', 0)
          .transition()
          .delay(function (d, i) { return i * 300 })
          .style('opacity', 1);

        thumb.append('div')
          .attr('class', "thumb-eyebrow")
          .style('opacity', 0)
          .transition()
          .delay(function (d, i) { return i * 300 })
          .style('opacity', 1)
          .text(function (d) { return d });
      };




      //Define Chatbot
      cb = chatbot(d3.select('#gui-2'));
      cb.showInput();

      /*Define bubble types*/

      /*Add a feedback textarea*/
      cb.types['feedback'] = function (bubble, options, callback) {
        var feedbackWrapper = bubble.append('div').classed('feedback', true);
        feedbackWrapper.append('textarea').attr('id', 'feedback')
          .attr('placeholder', 'Feedback')
      }

      /* Show bubbles which resize the viz*/
      cb.types['resize'] = function (bubble, options, callback) {

        var sizes = [
          { 'name': 'square', 'format': [100, 100], 'pic': 'smile' },
          { 'name': 'landscape', 'format': [100, 50], 'pic': 'smile' },
          { 'name': 'portrait', 'format': [100, 120], 'pic': 'smile' },

        ];

        bubble.style('background-color', '#fff');
        bubble.selectAll('.cb-format')
          .data(sizes).enter().append('div')
          .attr('class', 'cb-format')
          // .text(function (d) { return d.name; })
          .on('click', function (d) {
            SVIFT.vis.resize(d.format);
            setTimeout(function () {
              SVIFT.vis.redraw();
            }, 700)
          })
          .append('img').attr('src', function (d) { return './assets/img/icons/format-icons/' + d.name + '.svg' });

      }


      /* A select bubble which returns inits a function*/
      cb.types['select'] = function (bubble, options, callback) {
        bubble.style('background-color', '#fff');
        bubble.selectAll('.cb-choice')
          .data(options.value).enter().append('div')
          .attr('class', 'cb-choice')
          .text(function (d) { return d.label; })
          .on('click', function (d) {

              //remove eventhandler from all bubbles when clicked
              bubble.selectAll('.cb-choice').on('click',null);
              d3.select(this).classed('cb-active', true);
              callback(d);

          });
      };

      /* Add input */
      cb.types['input'] = function (bubble, options, callback) {

        bubble.style('background-color', '#fff'); //in css
        bubble.attr('class', 'cb-bubble-input');

        //title input
        var titleWrapper = bubble.append('div').classed('title', true);
        titleWrapper.append('input')
          .attr('id', 'title')
          .attr('placeholder', 'Add your title here')
          .on('input', function () {
            SVIFT.table.text.update("#title-main", "#title", "title", "Your title")
          });

        var toggleTitle = titleWrapper.append('div')
          .classed('icon-toggle', true)
          .on('click', function (d) {
            SVIFT.table.text.toogle(this, "#title-main", "#title", "title", "Your title")
          });

        //sub title input
        var subtitleWrapper = bubble.append('div').classed('subtitle', true);
        subtitleWrapper.append('input')
          .attr('id', 'subtitle')
          .attr('placeholder', 'Add your subtitle here')
          .on('input', function () {
            SVIFT.table.text.update("#title-sub", "#subtitle", "subTitle", "Your sub title")
          });

        var toggleSubTitle = subtitleWrapper.append('div')
          .classed('icon-toggle', true)
          .on('click', function (d) {
            SVIFT.table.text.toogle(this, "#title-sub", "#subtitle", "subTitle", "Your sub title")
          });

        if (SVIFT.vis.config.data.format === "single-set") {

          var tableWrapper = bubble.append('div').attr("class", "table-wrapper");
          var table = tableWrapper.append('table').append('tbody');


          // SVIFT.table.column.number = table.selectAll('tr')
          //   .data(SVIFT.vis.config.data.data).enter().append('tr')

          // // SVIFT.table.column.number.each(function(d,i) { console.log(d); });

          // SVIFT.table.column.number.selectAll('td')
          //   .data(function(d){return d}).enter().append('td')
          //   .append('td').append('input')
          //   .attr('placeholder', function (d) {console.log(d); return d[1] })
          //   .attr("data-index", function (d, i) { return i })
          //   .on('input', SVIFT.helper.debouncer(function () {
          //     SVIFT.table.values.update(this);
          //   }, 500));


          SVIFT.table.column.title = table.append('tr');
          SVIFT.table.column.title.selectAll('td')
            .data(SVIFT.vis.config.data.data['set1']).enter().append('td')
            // .filter(function(d) {
            //  if (SVIFT.vis.config.data.format === "single-set" ) {
            //   return true; 
            //  } else {
            //   return false;
            //  }
            // })
            .append('input')
            .attr('placeholder', function (d) { return d[0] })
            .attr("data-index", function (d, i) { return i })
            .on('input', SVIFT.helper.debouncer(function () {
              SVIFT.table.lables.update(this);
            }, 500));

          SVIFT.table.column.number = table.append('tr');
          SVIFT.table.column.number.selectAll('td')
            .data(SVIFT.vis.config.data.data['set1']).enter().append('td').append('input')
            .attr('placeholder', function (d) { return d[1] })
            .attr("data-index", function (d, i) { return i })
            .on('input', SVIFT.helper.debouncer(function () {
              SVIFT.table.values.update(this);
            }, 500));


          var editColButtons = tableWrapper.append('div')
            .classed('column-editor-wrapper', true);

          var removeButton = editColButtons.append('div')
            .classed('column-editor-btn', true)
            .classed('btn-remove', true)
            .text('–')
            .classed('disabled-btn', true)
            .on('click', function (d) {
              SVIFT.table.column.remove()
            });

          var addButton = editColButtons.append('div')
            .classed('column-editor-btn', true)
            .classed('btn-add', true)
            .text('+')
            .on('click', function (d) {
              SVIFT.table.column.add();
            });

        }
        //if single Number
        if (SVIFT.vis.config.data.format === "one-val") {

          bubble.append('input')
            .classed('number', true)
            .attr('id', 'number')
            // .attr('type', 'number')
            .attr('placeholder', function () { return SVIFT.vis.config.data.data['set1'][0][1] })
            .attr("data-index", 0)
            .on('input', SVIFT.helper.debouncer(function () {
              SVIFT.table.values.update(this)
            }, 500));

        }

        var sourceWrapper = bubble.append('div').classed('source', true);
        sourceWrapper.append('input')
          .attr('id', 'source-input')
          .attr('placeholder', 'Add your source here')
          .on('input', function () {
            SVIFT.table.text.update("#source", "#source-input", "source", "Source: Your source")
          });
        var toogleSource = sourceWrapper.append('div')
          .classed('icon-toggle', true)
          .on('click', function (d) {
            SVIFT.table.text.toogle(this, "#source", "#source-input", "source", "Source: Your source")
          });

      };


      /* Add text */
      cb.types['text'] = function (bubble, options, callback) {


        if (('delay' in options) && options.delay) {
          var animatedCircles = '<div class="circle"></div><div class="circle"></div><div class="circle"></div>';
          bubble.append('div')
            .attr('class', 'cb-waiting')
            .html(animatedCircles);

          setTimeout(function () {

            bubble.select(".cb-waiting").remove();
            appendText(bubble, options, callback);

          }, (isNaN(options.delay) ? 1000 : options.delay));
        } else {
          appendText(bubble, options, callback);
        }

        function appendText(bubble, options, callback) {
          bubble.attr('class', 'bubble-ctn-' + options.class).append('p')
            .style("width", "50px")
            .html(options.value)
            .transition()
            .duration(200)
            .style("width", "auto")
            .style('opacity', 1);

          if (options.emoji) {
            bubble.append('img').attr('class', 'emoji').attr('src', './assets/emojis/' + options.emoji + '.png');
          }

          callback();
        }

      }

      /* Select a theme */
      cb.types['themes'] = function (bubble, options, callback) {

        var themes = [
          { 'name': 'mercury', 'color': '#71609B', 'font': 'Open Sans' },
          { 'name': 'venus', 'color': '#FE9592', 'font': 'Noto Serif' },
          { 'name': 'earth', 'color': '#B8E986', 'font': 'Roboto Mono' },
          { 'name': 'mars', 'color': '#FF5C5C', 'font': 'Open Sans' },
          { 'name': 'jupiter', 'color': '#75FABF', 'font': 'Noto Serif' },
          { 'name': 'saturn', 'color': '#FBC469', 'font': 'Roboto Mono' },
          { 'name': 'uranus', 'color': '#83C4FE', 'font': 'Open Sans' },
          { 'name': 'neptune', 'color': '#4554A5', 'font': 'Noto Serif' },
          { 'name': 'pluto', 'color': '#454545', 'font': 'Roboto Mono' }
        ]

        var themesWrapper = bubble.append('div')
          .attr('class', 'cb-themes-wrapper');

        themesWrapper.selectAll('div').data(themes).enter()
          .append('div')
          .attr('class', function (d) { return 'theme-thumb theme-thumb-' + d.name })
          .on('click', function (d) {
            selectTheme(d);
          })
          .append('img')
          .attr('src', function (d) { return './assets/img/themes/theme-' + d.name + '.png' });

        function selectTheme(d) {

          SVIFT.vis.config.style.color.main = d.color;
          SVIFT.vis.config.style.font = d.font;
          SVIFT.vis.redraw();

        };
      }

      /* Add download buttons */
      cb.types['status'] = function (bubble, options, callback) {

        SVIFT.status = {};
        SVIFT.status.rows = {};

        var downloadWrapper = bubble.append('div')
          .attr('class', 'cb-status-wrapper')

        SVIFT.status.rows.rowOne = downloadWrapper.append('div')
          .attr('class', 'cb-status-row')
          .text('Images:');

        var socials = ['Twitter', 'LinkIn', 'Facebook','Snapchat','Pinterest','and more'];

        SVIFT.status.rows.rowOne.selectAll('span').data(socials).enter()
          .append('span')
          .text(function (d) { return d })
          .attr('class', 'cb-status-btn');


        SVIFT.status.rows.rowTwo = downloadWrapper.append('div')
          .attr('class', 'cb-status-row')
          .text('Other:');

        var otherText = ['embed', 'SVG', 'Video Sequence', 'GIF']
        var other = ['html', 'svg', 'png', 'gif'];
        SVIFT.status.rows.rowTwo.selectAll('span').data(other).enter()
          .append('span')
          .text(function (d,i) { return otherText[i] })
          .attr('class','cb-status-btn')
          .attr('id',function (d) { return 'status-' + d });

      }









      /*Start Chatbot*/

      cb.addBubble({ type: 'text', value: 'Hi there, welcome to SVIFT!', class: 'bot', emoji: 'wave', delay: 1000 }, function () {
        cb.addBubble({ type: 'text', value: 'Want to visualize some data for your project?', class: 'bot', delay: 500 }, function () {
          setTimeout(function () {
            cb.addBubble({ type: 'select', value: [{ label: 'Sounds great! Let’s go!' }], class: 'human' }, onEntry);
          }, 100)
        });
      });

      function onEntry(d) {
        cb.addBubble({ type: 'text', value: 'Ok then, choose your chart type on the left side!', class: 'bot', delay: 500 });
        setTimeout(function () {
          createThumbs();
        }, 500)
        d3.select('.inner').transition().delay(1000).style('display', 'none');
        d3.select('#gui-1').transition().delay(1000).style('background', '#75FABF');

      }


      function selectViz() {
        var tile = d3.selectAll('.thumb');
        tile.on('click', function (d) {

          cb.addBubble({ type: 'text', value: 'I want to make a ' + d + ' chart ', class: 'human', emoji: 'smile' }, function () {
            cb.addBubble({ type: 'text', value: "Good choice! Let's enter your data ", class: 'bot', emoji: 'write', delay: 500 }, function () {

              SVIFT.vis.init(d);

              setTimeout(function () {

                cb.addBubble({ type: 'input', class: 'human' });
                cb.addBubble({ type: 'select', value: [{ label: 'I am done entering my data!' }], class: 'human' }, onDataSubmitted);

              }, 500)
            });
          })
        });
      }


      function onDataSubmitted() {

        cb.addBubble({ type: 'text', value: 'Ok, last step: Choose your design! ', class: 'bot', emoji: 'style', delay: 500 }, function () {

          cb.addBubble({ type: 'themes', class: 'human' });

          setTimeout(function () {

            cb.addBubble({ type: 'select', value: [{ label: 'I am done!' }], class: 'human send' }, onFinish);

          }, 500)

        })

      }


      function onFinish() {

        //start rendering process
        SVIFT.vis.render();

        cb.addBubble({ type: 'text', value: 'Look you can preview your chart in different formats', class: 'bot', delay: 1500 }, function () {

          cb.addBubble({ type: 'resize', class: 'human' });

          setTimeout(function () {

          cb.addBubble({ type: 'select', value: [{ label: 'WoW!' }], class: 'human' }, function () {

            cb.addBubble({ type: 'text', value: 'Please wait while I build your chart', class: 'bot', emoji: 'smile' });
            cb.addBubble({ type: 'status', class: 'human' });

            SVIFT.vis.render.status.visible = true;
            SVIFT.vis.render.status.show();

          })

          }, 500)

        })


      }

      doneRendering = function () {

        cb.addBubble({ type: 'text', value: '<span>Get your charts here:<br><a class="bubble-link" target="_blank" style="text-decoration: none; color:rgba(113, 96, 155, 1);"href="' + './download.html#' + SVIFT.vis.render.token + '">www.svift.xyz/' + SVIFT.vis.render.token + '</a></span>', class: 'bot' });

        setTimeout(function () {

          cb.addBubble({ type: 'text', value: 'Thanks for using svift! What would you like to do next?', class: 'bot', delay: 1000 });

          setTimeout(function () {

            cb.addBubble({ type: 'select', value: [{ label: 'Give feedback', feedback: true }, { label: 'Make another data snap', feedback: false }], class: 'human' }, function (d) {

              if (d.feedback) {
                cb.addBubble({ type: 'feedback', class: 'human' });
                cb.addBubble({ type: 'select', value: [{ label: 'send feedback' }], class: 'human' }, function () {
                  var feedbackText = d3.select("#feedback").node().value;
                  console.log(feedbackText)
                  cb.addBubble({ type: 'text', value: 'Thanks for your feedback!!', class: 'bot' });
                  setTimeout(function () {
                    cb.addBubble({ type: 'select', value: [{ label: 'Make another data snap!' }], class: 'human' }, function () {
                      location.reload();
                    });
                  }, 500)

                })
              } else {
                location.reload();
              }
            });

          }, 1100)

        }, 1500)
      }

    });

  </script>
</body>

</html>